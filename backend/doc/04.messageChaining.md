# 메시지 체이닝(대화 컨텍스트) 구현 계획 (개정판)

## 문서 정보
- **작성일**: 2025-10-29
- **개정일**: 2025-10-30
- **버전**: 2.0
- **대상**: 백엔드/프론트엔드 개발자
- **범위**: 백엔드 API + 프론트 UI 연동 + 테스트
- **관련 파일**:
  - backend/app/routers/messages.py
  - backend/app/utils/claude_client.py
  - backend/app/database/{topic_db.py,message_db.py,ai_usage_db.py,artifact_db.py}
  - backend/app/utils/response_helper.py
  - shared/types/enums.py

---

## 📋 개정 이력

### v2.0 (2025-10-30)
- ✅ API 경로 단순화: `/api/topics/{topic_id}/messages/ask` → `/api/topics/{topic_id}/ask`
- ✅ Request Body 옵션 구조 단순화 (80/20 원칙 적용)
- ✅ 컨텍스트 구성 로직 명확화 (명시적 규칙 정의)
- ✅ ErrorCode 추가 정의 (MESSAGE.CONTEXT_TOO_LARGE 등)
- ✅ 아티팩트 저장 정책 명확화 (모든 응답 필수 저장)
- ✅ 로깅 전략 추가 (각 단계별 상세 로깅)

---

## 1. 기능 개요

### 목적
- 화면에서 사용자가 대화를 이어갈 수 있도록 "메시지 체이닝"을 제공한다.
- 화면 입력 프롬프트와 해당 토픽(topic)에 저장된 모든 메시지(`messages.content`)를 포함해 Claude에 질의한다.
- 응답은 Markdown으로 반환하고, 메시지·토큰 사용량·**아티팩트(MD 파일)**를 데이터베이스에 기록한다.
- **모든 assistant 응답은 MD 파일로 저장**되어 버전 관리 및 HWPX 변환에 활용된다.

### 사용자 플로우
```
1) 사용자가 화면에서 추가 질문 입력 (React 클라이언트)
   - 선택 옵션(간소화):
     * artifact_id: 특정 문서 참조 (null이면 최신 문서 자동 사용)
     * include_artifact_content: 파일 내용 포함 여부 (기본 true)

2) 백엔드에서 컨텍스트 구성
   - user 메시지: 모두 포함 (max_messages 제한 가능)
   - assistant 메시지: 참조 문서를 생성한 메시지 1건만 포함
   - 문서 내용: include_artifact_content=true일 때 별도 메시지로 주입

3) Claude 호출 및 응답 저장
   - MD 파일 자동 생성 (모든 응답 필수)
   - 메시지/사용량/아티팩트 DB 기록
```

### 기술적 플로우
```
[프론트] input → POST /api/topics/{topic_id}/ask
     ↓
[백엔드] 권한 검증 → user 메시지 저장 → 컨텍스트 구성
     ↓
[Claude] chat_completion(system + messages[]) 호출
     ↓
[백엔드] assistant 메시지 저장 → MD 파일 저장(필수) → Artifact 생성 → AiUsage 저장
     ↓
[프론트] 메시지 목록 갱신, 아티팩트 다운로드, 토큰 사용량 UI 표시
```

---

## 2. API 명세: 메시지 체이닝 (간소화)

### Endpoint (개정)
```
POST /api/topics/{topic_id}/ask
```

**변경 이유**: `/messages`가 중복됨. 토픽에 질문한다는 의미가 더 명확함.

### Path Parameters
| 이름 | 타입 | 필수 | 설명 |
|---|---|---|---|
| topic_id | integer | ✅ | 대화가 속한 토픽 ID |

### Request Body (단순화)
```json
{
  "content": "이전 분석에 이어 ESG 리스크 항목을 확장해 주세요.",
  "artifact_id": 123,
  "include_artifact_content": true,
  "max_messages": 50,
  "system_prompt": "선택적 커스텀 시스템 프롬프트"
}
```

**필드 설명**:
| 필드 | 타입 | 필수 | 기본값 | 설명 |
|------|------|------|--------|------|
| content | string | ✅ | - | 사용자 입력 (1~50,000자) |
| artifact_id | integer \| null | ❌ | null | 참조할 MD 아티팩트 ID. null이면 최신 MD 자동 사용 |
| include_artifact_content | boolean | ❌ | true | 파일 내용을 컨텍스트에 포함할지 여부. false면 해당 assistant 메시지만 포함 |
| max_messages | integer | ❌ | null | 포함할 최대 사용자 메시지 수 (null이면 전체) |
| system_prompt | string | ❌ | 기본 프롬프트 | 커스텀 시스템 프롬프트 (토픽 주제로 자동 보강됨) |

**단순화 전후 비교**:
```json
// 이전 (v1.0)
{
  "content": "...",
  "options": {
    "reference_mode": "latest",
    "md_artifact_id": 123,
    "md_reference_via": "artifact",
    "md_context_mode": "full",
    "md_max_chars": 30000,
    "max_context_messages": 50,
    "system_prompt": "..."
  }
}

// 현재 (v2.0 - 80%는 기본값 사용)
{
  "content": "...",
  "artifact_id": 123,  // null이면 latest
  "include_artifact_content": true  // false면 assistant만
}
```

### Success Response (200) — 표준 규격 준수
```json
{
  "success": true,
  "data": {
    "topic_id": 12,
    "user_message": {
      "id": 101,
      "topic_id": 12,
      "role": "user",
      "content": "이전 분석에 이어 ESG 리스크 항목을 확장해 주세요.",
      "seq_no": 7,
      "created_at": "2025-10-30T10:30:00"
    },
    "assistant_message": {
      "id": 102,
      "topic_id": 12,
      "role": "assistant",
      "content": "# ESG 리스크 확장 분석\n\n## 요약\n...",
      "seq_no": 8,
      "created_at": "2025-10-30T10:30:05"
    },
    "artifact": {
      "id": 345,
      "kind": "md",
      "filename": "report.md",
      "file_path": "D:/WorkSpace/.../backend/artifacts/12/v3/report.md",
      "file_size": 5432,
      "version": 3,
      "created_at": "2025-10-30T10:30:05"
    },
    "usage": {
      "model": "claude-sonnet-4-5-20250929",
      "input_tokens": 2300,
      "output_tokens": 950,
      "latency_ms": 3200
    }
  },
  "error": null,
  "meta": {
    "requestId": "req_abc123"
  },
  "feedback": []
}
```

### Error Responses

**400 Bad Request — 입력 검증 실패**
```json
{
  "success": false,
  "data": null,
  "error": {
    "code": "VALIDATION.REQUIRED_FIELD",
    "httpStatus": 400,
    "message": "입력 메시지가 비어있습니다.",
    "hint": "1자 이상 입력해주세요.",
    "traceId": "trace_xxx"
  },
  "meta": { "requestId": "req_xxx" },
  "feedback": []
}
```

**400 Bad Request — 컨텍스트 길이 초과 (신규)**
```json
{
  "success": false,
  "data": null,
  "error": {
    "code": "MESSAGE.CONTEXT_TOO_LARGE",
    "httpStatus": 400,
    "message": "컨텍스트 크기가 너무 큽니다.",
    "details": {
      "total_chars": 75000,
      "max_chars": 50000
    },
    "hint": "max_messages를 줄이거나 include_artifact_content를 false로 설정해주세요.",
    "traceId": "trace_yyy"
  },
  "meta": { "requestId": "req_yyy" },
  "feedback": []
}
```

**403 Forbidden — 권한 없음**
- `TOPIC.UNAUTHORIZED`: 토픽 소유자 아님
- `ARTIFACT.UNAUTHORIZED`: 다른 사용자의 아티팩트 접근

**404 Not Found**
- `TOPIC.NOT_FOUND`: 토픽 없음
- `ARTIFACT.NOT_FOUND`: artifact_id 지정 시 없음

**400 Bad Request — 아티팩트 형식 오류**
- `ARTIFACT.INVALID_KIND`: MD가 아닌 artifact (HWPX 등)

**503 Service Unavailable — Claude 호출 실패**
- `SERVER.SERVICE_UNAVAILABLE`: Claude API 장애

**500 Internal Server Error**
- `SERVER.INTERNAL_ERROR`: 기타 내부 오류

---

## 3. 컨텍스트 구성 로직 (명확화)

### 3.1 기본 원칙
- **user 메시지**: 모두 포함 (`max_messages` 제한 가능)
- **assistant 메시지**: 참조 문서를 생성한 메시지 **1건만** 포함
- **문서 내용**: `include_artifact_content=true`일 때 별도 user 메시지로 주입
- **정렬**: `seq_no ASC` (시간순)
- **길이 제한**: 전체 컨텍스트 50,000자 컷오프 (초과 시 400 에러)

### 3.2 참조 문서 선택 규칙

```python
# 의사코드
if artifact_id is not None:
    # 사용자가 명시적으로 지정
    reference_artifact = ArtifactDB.get_artifact_by_id(artifact_id)
    if not reference_artifact:
        return error_response(ErrorCode.ARTIFACT_NOT_FOUND, 404, ...)
    if reference_artifact.kind != ArtifactKind.MD:
        return error_response(ErrorCode.ARTIFACT_INVALID_KIND, 400, ...)
else:
    # 최신 MD 자동 선택
    reference_artifact = ArtifactDB.get_latest_artifact_by_kind(
        topic_id, ArtifactKind.MD, topic.language
    )
    if not reference_artifact:
        # MD가 하나도 없으면 참조 없이 진행 (graceful)
        reference_artifact = None
```

### 3.3 assistant 메시지 포함 규칙

```python
# 의사코드
all_messages = MessageDB.get_messages_by_topic(topic_id)

# User 메시지 필터링
user_messages = [m for m in all_messages if m.role == MessageRole.USER]
if max_messages is not None:
    user_messages = user_messages[-max_messages:]  # 최근 N개

# Assistant 메시지 필터링 (참조 문서를 생성한 메시지 1건만)
assistant_messages = []
if reference_artifact:
    ref_assistant_msg = MessageDB.get_message_by_id(reference_artifact.message_id)
    if ref_assistant_msg:
        assistant_messages = [ref_assistant_msg]

# 컨텍스트 배열 구성 (seq_no 순으로 정렬)
context_messages = sorted(
    user_messages + assistant_messages,
    key=lambda m: m.seq_no
)
```

### 3.4 문서 내용 주입 규칙

```python
# 의사코드
if include_artifact_content and reference_artifact:
    # 파일 읽기
    with open(reference_artifact.file_path, 'r', encoding='utf-8') as f:
        md_content = f.read()

    # 길이 제한 (안전 컷오프)
    MAX_MD_CHARS = 30000
    if len(md_content) > MAX_MD_CHARS:
        md_content = md_content[:MAX_MD_CHARS] + "\n\n... (truncated)"

    # 별도 메시지로 주입 (role=user, 가장 최근 위치)
    artifact_context_msg = {
        "role": "user",
        "content": f"""현재 보고서(MD) 원문입니다. 개정 시 이를 기준으로 반영하세요.

```markdown
{md_content}
```"""
    }

    # 컨텍스트 끝에 추가 (최신 위치)
    context_messages.append(artifact_context_msg)
```

### 3.5 시스템 프롬프트 구성

```python
# 의사코드
if system_prompt:
    # 사용자 커스텀 프롬프트 사용
    final_system_prompt = system_prompt
else:
    # 기본 프롬프트 + 토픽 주제 보강
    default_prompt = """당신은 금융 기관의 전문 보고서 작성자입니다.
사용자의 요청에 따라 전문적이고 격식있는 금융 업무보고서를 Markdown 형식으로 작성해주세요.

보고서는 다음 섹션을 포함해야 합니다:
- # 제목 (H1)
- ## 요약 (H2)
- ## 배경 및 목적 (H2)
- ## 주요 내용 (H2)
- ## 결론 및 제언 (H2)

명확하고 이해하기 쉽게 작성하되, 금융 용어와 데이터를 적절히 활용하여 신뢰성을 높여주세요.
모든 출력은 Markdown 형식이어야 합니다."""

    topic_context = f"\n\n**대화 주제**: {topic.input_prompt}\n이전 메시지를 문맥으로 활용하여 일관된 문체와 구조로 답변하세요."

    final_system_prompt = default_prompt + topic_context
```

### 3.6 전체 컨텍스트 검증

```python
# 의사코드
# Claude API로 전달할 messages 배열 구성
claude_messages = [
    {"role": m.role.value, "content": m.content}
    for m in context_messages
]

# 길이 검증 (안전 제한)
total_chars = sum(len(msg["content"]) for msg in claude_messages)
MAX_CONTEXT_CHARS = 50000

if total_chars > MAX_CONTEXT_CHARS:
    return error_response(
        code=ErrorCode.MESSAGE_CONTEXT_TOO_LARGE,
        http_status=400,
        message="컨텍스트 크기가 너무 큽니다.",
        details={"total_chars": total_chars, "max_chars": MAX_CONTEXT_CHARS},
        hint="max_messages를 줄이거나 include_artifact_content를 false로 설정해주세요."
    )
```

---

## 4. 백엔드 구현 세부사항

### 4.1 엔드포인트 구현 흐름

```python
@router.post("/api/topics/{topic_id}/ask", summary="Ask question in conversation")
async def ask(
    topic_id: int,
    body: AskRequest,
    current_user: User = Depends(get_current_active_user)
):
    """Ask a question in the conversation context.

    Args:
        topic_id: Topic ID
        body: Request body with content and options
        current_user: Authenticated user

    Returns:
        Standard ApiResponse with user_message, assistant_message, artifact, usage

    Error Codes:
        - TOPIC.NOT_FOUND: Topic not found
        - TOPIC.UNAUTHORIZED: User does not own this topic
        - VALIDATION.REQUIRED_FIELD: Content is empty
        - ARTIFACT.NOT_FOUND: Specified artifact not found
        - ARTIFACT.INVALID_KIND: Artifact is not MD
        - ARTIFACT.UNAUTHORIZED: Artifact belongs to different user
        - MESSAGE.CONTEXT_TOO_LARGE: Context size exceeds limit
        - SERVER.SERVICE_UNAVAILABLE: Claude API failure
    """

    # === 1단계: 권한 및 검증 ===
    logger.info(f"[ASK] Start - topic_id={topic_id}, user_id={current_user.id}")

    topic = TopicDB.get_topic_by_id(topic_id)
    if not topic:
        logger.warning(f"[ASK] Topic not found - topic_id={topic_id}")
        return error_response(
            code=ErrorCode.TOPIC_NOT_FOUND,
            http_status=404,
            message="토픽을 찾을 수 없습니다."
        )

    if topic.user_id != current_user.id and not current_user.is_admin:
        logger.warning(f"[ASK] Unauthorized - topic_id={topic_id}, owner={topic.user_id}, requester={current_user.id}")
        return error_response(
            code=ErrorCode.TOPIC_UNAUTHORIZED,
            http_status=403,
            message="이 토픽에 접근할 권한이 없습니다."
        )

    content = (body.content or "").strip()
    if not content:
        logger.warning(f"[ASK] Empty content - topic_id={topic_id}")
        return error_response(
            code=ErrorCode.VALIDATION_REQUIRED_FIELD,
            http_status=400,
            message="입력 메시지가 비어있습니다.",
            hint="1자 이상 입력해주세요."
        )

    if len(content) > 50000:
        logger.warning(f"[ASK] Content too long - topic_id={topic_id}, length={len(content)}")
        return error_response(
            code=ErrorCode.VALIDATION_MAX_LENGTH_EXCEEDED,
            http_status=400,
            message="입력 메시지가 너무 깁니다.",
            hint="50,000자 이하로 입력해주세요."
        )

    # === 2단계: 사용자 메시지 저장 ===
    logger.info(f"[ASK] Saving user message - topic_id={topic_id}, length={len(content)}")
    user_msg = MessageDB.create_message(
        topic_id,
        MessageCreate(role=MessageRole.USER, content=content)
    )
    logger.info(f"[ASK] User message saved - message_id={user_msg.id}, seq_no={user_msg.seq_no}")

    # === 3단계: 참조 문서 선택 ===
    reference_artifact = None
    if body.artifact_id is not None:
        logger.info(f"[ASK] Loading specified artifact - artifact_id={body.artifact_id}")
        reference_artifact = ArtifactDB.get_artifact_by_id(body.artifact_id)

        if not reference_artifact:
            logger.warning(f"[ASK] Artifact not found - artifact_id={body.artifact_id}")
            return error_response(
                code=ErrorCode.ARTIFACT_NOT_FOUND,
                http_status=404,
                message="지정한 아티팩트를 찾을 수 없습니다."
            )

        if reference_artifact.topic_id != topic_id:
            logger.warning(f"[ASK] Artifact topic mismatch - artifact.topic_id={reference_artifact.topic_id}, request.topic_id={topic_id}")
            return error_response(
                code=ErrorCode.ARTIFACT_UNAUTHORIZED,
                http_status=403,
                message="이 아티팩트에 접근할 권한이 없습니다."
            )

        if reference_artifact.kind != ArtifactKind.MD:
            logger.warning(f"[ASK] Invalid artifact kind - artifact_id={body.artifact_id}, kind={reference_artifact.kind}")
            return error_response(
                code=ErrorCode.ARTIFACT_INVALID_KIND,
                http_status=400,
                message="MD 형식의 아티팩트만 참조할 수 있습니다.",
                details={"current_kind": reference_artifact.kind}
            )
    else:
        logger.info(f"[ASK] Loading latest MD artifact - topic_id={topic_id}")
        reference_artifact = ArtifactDB.get_latest_artifact_by_kind(
            topic_id, ArtifactKind.MD, topic.language
        )
        if reference_artifact:
            logger.info(f"[ASK] Latest artifact found - artifact_id={reference_artifact.id}, version={reference_artifact.version}")
        else:
            logger.info(f"[ASK] No MD artifact found - proceeding without reference")

    # === 4단계: 컨텍스트 구성 ===
    logger.info(f"[ASK] Building context - topic_id={topic_id}")

    all_messages = MessageDB.get_messages_by_topic(topic_id)
    logger.info(f"[ASK] Total messages in topic: {len(all_messages)}")

    # User 메시지 필터링
    user_messages = [m for m in all_messages if m.role == MessageRole.USER]
    if body.max_messages is not None:
        user_messages = user_messages[-body.max_messages:]
    logger.info(f"[ASK] User messages to include: {len(user_messages)}")

    # Assistant 메시지 필터링 (참조 문서 생성 메시지만)
    assistant_messages = []
    if reference_artifact:
        ref_msg = MessageDB.get_message_by_id(reference_artifact.message_id)
        if ref_msg:
            assistant_messages = [ref_msg]
            logger.info(f"[ASK] Including reference assistant message - message_id={ref_msg.id}")

    # 컨텍스트 배열 구성
    context_messages = sorted(
        user_messages + assistant_messages,
        key=lambda m: m.seq_no
    )

    # 문서 내용 주입
    if body.include_artifact_content and reference_artifact:
        logger.info(f"[ASK] Loading artifact content - artifact_id={reference_artifact.id}, path={reference_artifact.file_path}")

        try:
            with open(reference_artifact.file_path, 'r', encoding='utf-8') as f:
                md_content = f.read()

            original_length = len(md_content)
            MAX_MD_CHARS = 30000
            if len(md_content) > MAX_MD_CHARS:
                md_content = md_content[:MAX_MD_CHARS] + "\n\n... (truncated)"
                logger.info(f"[ASK] Artifact content truncated - original={original_length}, truncated={MAX_MD_CHARS}")

            artifact_msg = type('Message', (), {
                'role': MessageRole.USER,
                'content': f"""현재 보고서(MD) 원문입니다. 개정 시 이를 기준으로 반영하세요.

```markdown
{md_content}
```""",
                'seq_no': context_messages[-1].seq_no + 0.5 if context_messages else 0
            })()

            context_messages.append(artifact_msg)
            logger.info(f"[ASK] Artifact content injected - length={len(md_content)}")

        except Exception as e:
            logger.error(f"[ASK] Failed to load artifact content - error={str(e)}")
            return error_response(
                code=ErrorCode.ARTIFACT_DOWNLOAD_FAILED,
                http_status=500,
                message="아티팩트 파일을 읽을 수 없습니다.",
                details={"error": str(e)}
            )

    # Claude 메시지 배열 변환
    claude_messages = [
        {"role": m.role.value, "content": m.content}
        for m in context_messages
    ]

    # 길이 검증
    total_chars = sum(len(msg["content"]) for msg in claude_messages)
    MAX_CONTEXT_CHARS = 50000

    logger.info(f"[ASK] Context size - messages={len(claude_messages)}, total_chars={total_chars}, max={MAX_CONTEXT_CHARS}")

    if total_chars > MAX_CONTEXT_CHARS:
        logger.warning(f"[ASK] Context too large - total_chars={total_chars}")
        return error_response(
            code=ErrorCode.MESSAGE_CONTEXT_TOO_LARGE,
            http_status=400,
            message="컨텍스트 크기가 너무 큽니다.",
            details={"total_chars": total_chars, "max_chars": MAX_CONTEXT_CHARS},
            hint="max_messages를 줄이거나 include_artifact_content를 false로 설정해주세요."
        )

    # 시스템 프롬프트 구성
    if body.system_prompt:
        system_prompt = body.system_prompt
        logger.info(f"[ASK] Using custom system prompt - length={len(system_prompt)}")
    else:
        default_prompt = """당신은 금융 기관의 전문 보고서 작성자입니다.
사용자의 요청에 따라 전문적이고 격식있는 금융 업무보고서를 Markdown 형식으로 작성해주세요.

보고서는 다음 섹션을 포함해야 합니다:
- # 제목 (H1)
- ## 요약 (H2)
- ## 배경 및 목적 (H2)
- ## 주요 내용 (H2)
- ## 결론 및 제언 (H2)

명확하고 이해하기 쉽게 작성하되, 금융 용어와 데이터를 적절히 활용하여 신뢰성을 높여주세요.
모든 출력은 Markdown 형식이어야 합니다."""

        topic_context = f"\n\n**대화 주제**: {topic.input_prompt}\n이전 메시지를 문맥으로 활용하여 일관된 문체와 구조로 답변하세요."
        system_prompt = default_prompt + topic_context
        logger.info(f"[ASK] Using default system prompt with topic context")

    # === 5단계: Claude 호출 ===
    logger.info(f"[ASK] Calling Claude API - model={ClaudeClient().model}, messages={len(claude_messages)}")

    try:
        import time
        t0 = time.time()

        claude_client = ClaudeClient()
        response_text, input_tokens, output_tokens = claude_client.chat_completion(
            claude_messages,
            system_prompt
        )

        latency_ms = int((time.time() - t0) * 1000)

        logger.info(f"[ASK] Claude response received - input_tokens={input_tokens}, output_tokens={output_tokens}, latency_ms={latency_ms}")

    except Exception as e:
        logger.error(f"[ASK] Claude API call failed - error={str(e)}")
        return error_response(
            code=ErrorCode.SERVER_SERVICE_UNAVAILABLE,
            http_status=503,
            message="AI 응답 생성 중 오류가 발생했습니다.",
            details={"error": str(e)},
            hint="잠시 후 다시 시도해주세요."
        )

    # === 6단계: Assistant 메시지 저장 ===
    logger.info(f"[ASK] Saving assistant message - topic_id={topic_id}, length={len(response_text)}")

    asst_msg = MessageDB.create_message(
        topic_id,
        MessageCreate(role=MessageRole.ASSISTANT, content=response_text)
    )

    logger.info(f"[ASK] Assistant message saved - message_id={asst_msg.id}, seq_no={asst_msg.seq_no}")

    # === 7단계: MD 파일 저장 (필수) ===
    logger.info(f"[ASK] Saving MD artifact - topic_id={topic_id}")

    try:
        from app.utils.file_utils import next_artifact_version, build_artifact_paths, write_text, sha256_of

        # 버전 계산
        version = next_artifact_version(topic_id, ArtifactKind.MD, topic.language)
        logger.info(f"[ASK] Artifact version - version={version}")

        # 파일 경로 생성
        base_dir, md_path = build_artifact_paths(topic_id, version, "report.md")
        logger.info(f"[ASK] Artifact path - path={md_path}")

        # 파일 저장
        bytes_written = write_text(md_path, response_text)
        file_hash = sha256_of(md_path)

        logger.info(f"[ASK] File written - size={bytes_written}, hash={file_hash[:16]}...")

        # Artifact DB 레코드 생성
        artifact = ArtifactDB.create_artifact(
            topic_id,
            asst_msg.id,
            ArtifactCreate(
                kind=ArtifactKind.MD,
                locale=topic.language,
                version=version,
                filename=md_path.name,
                file_path=str(md_path),
                file_size=bytes_written,
                sha256=file_hash
            )
        )

        logger.info(f"[ASK] Artifact created - artifact_id={artifact.id}, version={artifact.version}")

    except Exception as e:
        logger.error(f"[ASK] Failed to save artifact - error={str(e)}")
        return error_response(
            code=ErrorCode.ARTIFACT_CREATION_FAILED,
            http_status=500,
            message="응답 파일 저장 중 오류가 발생했습니다.",
            details={"error": str(e)}
        )

    # === 8단계: AI 사용량 저장 ===
    logger.info(f"[ASK] Saving AI usage - message_id={asst_msg.id}")

    try:
        from app.database.ai_usage_db import AiUsageDB
        from app.models.ai_usage import AiUsageCreate

        AiUsageDB.create_ai_usage(
            topic_id,
            asst_msg.id,
            AiUsageCreate(
                model=claude_client.model,
                input_tokens=input_tokens,
                output_tokens=output_tokens,
                latency_ms=latency_ms
            )
        )

        logger.info(f"[ASK] AI usage saved")

    except Exception as e:
        logger.error(f"[ASK] Failed to save AI usage - error={str(e)}")
        # 사용량 저장 실패는 치명적이지 않으므로 계속 진행

    # === 9단계: 성공 응답 반환 ===
    logger.info(f"[ASK] Success - topic_id={topic_id}, artifact_id={artifact.id}")

    return success_response({
        "topic_id": topic_id,
        "user_message": MessageResponse.model_validate(user_msg).model_dump(),
        "assistant_message": MessageResponse.model_validate(asst_msg).model_dump(),
        "artifact": ArtifactResponse.model_validate(artifact).model_dump(),
        "usage": {
            "model": claude_client.model,
            "input_tokens": input_tokens,
            "output_tokens": output_tokens,
            "latency_ms": latency_ms
        }
    })
```

---

## 5. Request/Response 모델 정의

### 5.1 Request Model

**파일**: `backend/app/models/message.py`

```python
from pydantic import BaseModel, Field
from typing import Optional


class AskRequest(BaseModel):
    """Request model for asking question in conversation.

    Attributes:
        content: User question (1-50,000 chars)
        artifact_id: Specific artifact to reference (null = use latest MD)
        include_artifact_content: Include file content in context (default: true)
        max_messages: Max number of user messages to include (null = all)
        system_prompt: Custom system prompt (optional)
    """

    content: str = Field(
        ...,
        min_length=1,
        max_length=50000,
        description="User question text"
    )

    artifact_id: Optional[int] = Field(
        default=None,
        description="Artifact ID to reference (null = use latest MD)"
    )

    include_artifact_content: bool = Field(
        default=True,
        description="Include artifact file content in context"
    )

    max_messages: Optional[int] = Field(
        default=None,
        ge=1,
        le=100,
        description="Maximum number of user messages to include"
    )

    system_prompt: Optional[str] = Field(
        default=None,
        max_length=10000,
        description="Custom system prompt"
    )
```

---

## 6. ErrorCode 추가 정의

**파일**: `backend/app/utils/response_helper.py`

```python
class ErrorCode:
    # ... 기존 코드 ...

    # Message errors (MESSAGE.*)
    MESSAGE_NOT_FOUND = "MESSAGE.NOT_FOUND"
    MESSAGE_CREATION_FAILED = "MESSAGE.CREATION_FAILED"
    MESSAGE_INVALID_ROLE = "MESSAGE.INVALID_ROLE"
    MESSAGE_CONTEXT_TOO_LARGE = "MESSAGE.CONTEXT_TOO_LARGE"  # 신규 추가
```

---

## 7. 로깅 전략

### 7.1 로깅 레벨 정책
- **INFO**: 정상 흐름의 주요 단계
- **WARNING**: 비정상적이나 처리 가능한 상황 (404, 403 등)
- **ERROR**: 예외 발생 및 실패 케이스

### 7.2 로깅 포맷
```python
logger.info(f"[ASK] {stage} - key1={value1}, key2={value2}")
```

### 7.3 필수 로깅 지점
1. **요청 시작**: topic_id, user_id
2. **권한 검증**: 성공/실패
3. **메시지 저장**: message_id, seq_no
4. **컨텍스트 구성**: 메시지 수, 총 문자 수
5. **Claude 호출**: 모델, 토큰 수, 지연시간
6. **파일 저장**: 경로, 크기, 해시
7. **응답 반환**: artifact_id

---

## 8. 테스트 계획

### 8.1 단위 테스트

**파일**: `backend/tests/test_routers_messages_ask.py`

```python
import pytest
from unittest.mock import patch


@pytest.mark.api
class TestAskEndpoint:
    """Ask endpoint tests"""

    def test_ask_success_no_artifact(self, client, auth_headers, create_test_user):
        """참조 문서 없이 질문 성공"""
        # 1. 토픽 생성
        topic = TopicDB.create_topic(...)

        # 2. Mock Claude
        with patch('app.utils.claude_client.Anthropic') as mock:
            mock_instance = MagicMock()
            mock_instance.messages.create.return_value.content = [
                type('Content', (), {'text': "# 응답\n\n내용..."})()
            ]
            mock_instance.messages.create.return_value.usage.input_tokens = 100
            mock_instance.messages.create.return_value.usage.output_tokens = 200
            mock.return_value = mock_instance

            # 3. Ask 호출
            response = client.post(
                f"/api/topics/{topic.id}/ask",
                headers=auth_headers,
                json={"content": "디지털뱅킹 트렌드를 분석해주세요."}
            )

        # 4. 검증
        assert response.status_code == 200
        body = response.json()
        assert body["success"] is True
        assert body["data"]["artifact"]["kind"] == "md"
        assert body["data"]["usage"]["input_tokens"] == 100

    def test_ask_with_latest_md(self, client, auth_headers, create_test_user):
        """최신 MD 참조하여 질문"""
        # 1. 토픽 + MD artifact 생성
        topic = TopicDB.create_topic(...)
        msg = MessageDB.create_message(...)
        artifact = ArtifactDB.create_artifact(..., kind=ArtifactKind.MD, ...)

        # 2. Ask 호출 (artifact_id=None, 자동으로 latest 사용)
        with patch('app.utils.claude_client.Anthropic'):
            response = client.post(
                f"/api/topics/{topic.id}/ask",
                headers=auth_headers,
                json={"content": "이전 보고서를 요약해주세요."}
            )

        # 3. 컨텍스트에 최신 MD 포함 확인 (로그 또는 Mock 호출 검증)
        assert response.status_code == 200

    def test_ask_with_specific_md(self, client, auth_headers, create_test_user):
        """특정 MD 지정하여 질문"""
        # 여러 버전 MD 생성 후 특정 ID 지정
        pass

    def test_ask_context_too_large(self, client, auth_headers, create_test_user):
        """컨텍스트 길이 초과"""
        # 매우 긴 메시지들 생성 후 요청
        # 400 MESSAGE.CONTEXT_TOO_LARGE 확인
        pass

    def test_ask_artifact_not_found(self, client, auth_headers, create_test_user):
        """존재하지 않는 artifact_id"""
        topic = TopicDB.create_topic(...)

        response = client.post(
            f"/api/topics/{topic.id}/ask",
            headers=auth_headers,
            json={"content": "질문", "artifact_id": 999999}
        )

        assert response.status_code == 404
        assert response.json()["error"]["code"] == "ARTIFACT.NOT_FOUND"

    def test_ask_artifact_wrong_kind(self, client, auth_headers, create_test_user):
        """HWPX artifact 참조 시도"""
        # HWPX artifact 생성 후 artifact_id 지정
        # 400 ARTIFACT.INVALID_KIND 확인
        pass

    def test_ask_unauthorized_topic(self, client, auth_headers, create_admin_user):
        """타인의 토픽에 질문"""
        # User A의 토픽 생성
        # User B로 요청
        # 403 TOPIC.UNAUTHORIZED 확인
        pass

    def test_ask_max_messages_limit(self, client, auth_headers, create_test_user):
        """max_messages 제한"""
        # 50개 user 메시지 생성
        # max_messages=10 설정
        # 최근 10개만 포함 확인
        pass
```

---

## 9. 마이그레이션 계획

### 9.1 기존 엔드포인트와의 공존
- 기존: `POST /api/topics/{topic_id}/messages` (시스템 전용)
- 신규: `POST /api/topics/{topic_id}/ask` (사용자 대화용)

### 9.2 프론트엔드 전환
- 기존 UI는 `ask` 엔드포인트 사용으로 전환
- `messages` 엔드포인트는 관리자/이관 용도로만 사용

---

## 10. 구현 체크리스트

### Phase 1: MVP (2일)
- [ ] `AskRequest` 모델 정의
- [ ] `POST /api/topics/{topic_id}/ask` 엔드포인트 구현
- [ ] 권한/검증 로직
- [ ] 컨텍스트 구성 (user 전체 + latest MD의 assistant)
- [ ] Claude 호출 및 응답 저장
- [ ] MD 파일 자동 저장 (필수)
- [ ] AI 사용량 기록
- [ ] ErrorCode 추가 (`MESSAGE.CONTEXT_TOO_LARGE`)
- [ ] 로깅 추가 (전 단계)
- [ ] 기본 테스트 (성공/실패)

### Phase 2: 옵션 기능 (1일)
- [ ] `artifact_id` 명시적 지정
- [ ] `include_artifact_content` 구현
- [ ] `max_messages` 제한
- [ ] 컨텍스트 길이 검증
- [ ] 추가 테스트 (옵션 조합)

### Phase 3: 안정화 (1일)
- [ ] 로깅 검증
- [ ] 에러 케이스 전체 테스트
- [ ] 문서 업데이트 (README/CLAUDE.md)
- [ ] 프론트엔드 연동 가이드

---

## 11. 성능/비용 고려

### 11.1 토큰 비용 제어
- `max_messages`로 컨텍스트 크기 제한
- 문서 내용 30,000자 컷오프
- 전체 컨텍스트 50,000자 하드 리미트

### 11.2 Rate Limiting (추후)
- 사용자당 분당 10회 제한
- IP 기반 제한 고려

### 11.3 모니터링
- 토큰 사용량 대시보드
- 평균 지연시간 추적
- 에러율 모니터링

---

## 부록 A: API 호출 예시

### 예시 1: 최초 질문 (참조 문서 없음)
```bash
POST /api/topics/12/ask
Authorization: Bearer {token}

{
  "content": "2025년 디지털뱅킹 트렌드를 분석해주세요."
}
```

### 예시 2: 후속 질문 (최신 MD 자동 참조)
```bash
POST /api/topics/12/ask
Authorization: Bearer {token}

{
  "content": "이전 분석에 ESG 리스크를 추가해주세요."
}
```

### 예시 3: 특정 버전 참조
```bash
POST /api/topics/12/ask
Authorization: Bearer {token}

{
  "content": "v2 보고서를 기준으로 요약해주세요.",
  "artifact_id": 345
}
```

### 예시 4: 파일 내용 제외 (assistant 메시지만)
```bash
POST /api/topics/12/ask
Authorization: Bearer {token}

{
  "content": "이전 답변을 간단히 요약해주세요.",
  "include_artifact_content": false
}
```

---

**문서 버전**: 2.0
**최종 검토**: 2025-10-30
**승인**: 기술 리드
